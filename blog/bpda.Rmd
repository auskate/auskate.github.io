---
title: Bayesian divergence point analysis of visual world data
author: Kate Stone
date: '2021-04-08'
#slug: []
#categories: []
#tags: []
Description: ''
#Tags: []
#Categories: []
DisableComments: yes
# draft: TRUE
header-includes:
- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
- <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
- <img src="/images/snorkelling2.PNG" alt="tetapare">
output:
  html_document:
    keep_md: yes # do this for each blog post
#always_allow_html: true # needs to be in each blog yaml header so that any html in an md file is rendered
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE, eval = TRUE)

library(tidyverse)
library(patchwork)

# base r plot settings
op <- par(cex.main = 2, mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0), cex.lab = 1.2, 
    font.lab = 2, cex.axis = 1, bty = "n", las = 1)

xlims  <- c(0, 1800)

# VW data
dat_exp2 <- read.table("E:/Academic/AGREE/papers/L1/data/data_experiment2.txt", header = TRUE) %>%
  filter(Blink == 0 & Saccade == 0 &
           Accuracy_Possessee == 1 &
           Interest_Area == 1,
         !(Naming %in% c("incorrect", "gender_error"))
         ) %>%
  select(-Blink, -Saccade, -Accuracy_Possessee, -Interest_Area)

# bootstrap data
bootres_exp2 <- readRDS("E:/Academic/AGREE/papers/L1/data/bootres_spritzer_L1paper_250Hz.rds")

# tidy bootstrap dataframes
bootstrap_samples <- data.frame(dp = bootres_exp2$t[,1]*20,
                      match = (bootres_exp2$t[,2]-1)*20, 
                      mismatch = (bootres_exp2$t[,3]-1)*20)

df_l1l2 <- bootstrap_samples %>%
  gather(key = "Condition", value = "onset")

# Create labels
labels <- c(match = "Match", 
            mismatch = "Mismatch", 
            dp = "Difference\nMismatch-Match")


# Order factor levels
df_l1l2$Condition <- factor(df_l1l2$Condition, levels = c("match", "mismatch", "dp"))


# define a range of onsets for which we would like to find onset probabilities
values <- seq(0, 1900, 1)


```


The visual world is a useful paradigm in psycholinguistics for tracking people's eye fixations as they listen to sentences containing some kind of experimental manipulation. A common question is whether the experimental manipulation makes people look at a target object earlier in one condition than another. To answer this, we need to decide *when* in each condition people start looking at the target and compare these timepoints between conditions. But this is not as straightforward as it sounds!^[There are several existing methods for answering temporal questions about visual world data, including [cluster permutation](https://doi.org/10.1037/a0031813), [BDOTS](https://doi.org/10.1016/j.jml.2018.05.004), and GAMMs. We summarise these in [Stone et al., 2020](https://doi.org/10.1017/S1366728920000607) and outline why they weren't able to answer our specific question about whether one onset was significantly faster than another.] We came up with a bootstrapping method to do this in [Stone, Lago & Schad, 2020](https://doi.org/10.1017/S1366728920000607). However, bootstrapping makes some unlikely assumptions about data---I'll come to these later---and so here we try to improve on these assumptions by adding Bayesian principles to our method. This was an approach developed with [João Veríssimo](https://www.jverissimo.net/), [Daniel Schad](https://danielschad.github.io/), and [Sol Lago](https://sollago.github.io/), and we apply it in [this paper](https://osf.io/3uz7x/).


### The bootstrap procedure

A full workthrough of our bootstrap procedure can be found in [Stone et al., 2020](https://doi.org/10.1017/S1366728920000607), but for a quick overview here, we use example data from an experiment on using syntactic gender to predict an upcoming noun in German. Participants heard sentences like “*Klicke auf seinen blauen…*” (click on his.~MASC~ blue.~MASC~ ...), while looking at two blue objects on a screen. Only one of the objects matched the gender marking of the pronoun and adjective. There were two experimental conditions: in the `match` condition, the target object and the object's owner matched in gender, e.g. *seinen Knopf* (his button.~MASC~). In the `mismatch` condition, the target object and the object's owner mismatched in gender, e.g. *ihren Knopf* (her button.~MASC~). 

<center>
![](images/objects.PNG){width=85% height=85%}
</center>

Because of the gender cue on the possessive and adjective (e.g. -en suffix), we expected participants to predict the target object and look preferentially at it before they heard its name. What we really wanted to know though was whether predictive looks would be delayed in the mismatch condition where there was a conflicting gender cue, even though the conflicting cue was syntactically irrelevant (i.e. the object's owner being masculine or feminine has no bearing on what the upcoming object might be). You can already see below that the onset of when participants looked preferentially at the target appears to be later in the mismatch condition: 




```{r, fig.width=6, fig.height=3.5, fig.align="center"}

# create plotting data
plot_exp2 <- dat_exp2 %>% 
  filter(between(Time, 0, 1900) & Condition %in% c("match","mismatch")) %>%
  # downsample to every 100ms
  filter(Time %% 50 == 0) %>%
  # rename and reorder factor levels
  mutate(Region = fct_relevel(fct_recode(Region, target = "target", 
                                         competitor = "ccolour"), "target")) %>% 
  # create mean fixation proportions by participant
  group_by(Participant, Condition, Region, Time) %>%
  summarise(MeanFixation = mean(Value))

# general plot settings
col         <- c("#08519C","#08519C")
facet_names <- c(match = "Match", mismatch = "Mismatch")
onsets      <- c(800, 1800)
lty         <- c("solid", "dotdash")

# data frame for adding words to the plot
words <- data.frame(plot_exp2) %>%  
  select(c("Condition")) %>% 
  distinct(.keep_all=TRUE) 



# plot
ggplot(plot_exp2, aes(Time, MeanFixation)) +
  stat_summary(fun.data = mean_cl_boot, 
               aes(fill = Region), geom = "ribbon", alpha = .25) +
  stat_summary(fun = mean, geom = "path", 
               aes(group = Region, colour = Region, linetype = Region), size = 1) +
  facet_grid(. ~ Condition, labeller = as_labeller(facet_names)) +
  # add vertical lines for time windows
  geom_hline(yintercept = .5, linetype = "dotted") +
  geom_vline(xintercept = onsets, linetype = "dashed", colour = "grey50") +
  
  # add word stimuli
  geom_text(data = subset(words, Condition == "match"), label = "seinen", y = .15, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  geom_text(data = subset(words, Condition == "mismatch"), label = "ihren", y = .14, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "blauen", x = onsets[1]-60, y = .15, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "Knopf", x = onsets[2]-60, y = .13, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +

  # axes and legends
  labs(x = "Time from possessive onset (ms)", y = "Fixation proportions") +
  scale_x_continuous(breaks = seq(0, 2500, 500), labels = seq(0, 2500, 500)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_linetype_manual(values = lty, name = "Object") +
  scale_colour_manual(values = col, name = "Object") +
  scale_fill_manual(values = col, name = "Object") +
  
  # theme settings
  theme_light() +
  theme(strip.text = element_text(size = 16), text = element_text(size = 14), legend.position = "top")




# ggsave("C:/repos/stonekate.github.io/static/images/fig2.png", fig2, height = 10, width = 10, dpi = 300)

```


But is this "prediction onset" in the mismatch condition *significantly* later than the match condition? We can find out using our bootstrapping procedure, which has the following steps:

1. Conduct a statistical test of fixations between the target and competitor at each timepoint in each condition (similar to a permutation test, e.g. [Groppe, Urbach & Kutas, 2011](https://doi.org/10.1111/j.1469-8986.2011.01273.x); [Maris & Oostenveldt, 2007](https://doi.org/10.1016/j.jneumeth.2007.03.024); [Barr, Jackson & Phillips, 2014](https://doi.org/10.1037/a0031813)),
2. Decide on an alpha (usually 0.05) and find the first significant test statistic in a run of five consecutive significant test statistics ([Sheridan & Reingold, 2012](https://doi.org/10.1080/13506285.2012.693548); [Reingold & Sheridan, 2014](https://doi.org/10.3389/fpsyg.2014.01432) take a similar approach).^[Depending on your experimental manipulation (e.g. how big or sustained you expect your experimental effect to be) and how you've set up your data (e.g. binned, unbinned, eye tracker sampling rate), your criterion for the number of consecutive significant tests may differ.] This was our divergence point for each condition, which we consider the onset of evidence for predictions,
3. Resample the data 2000 times with replacement and repeat steps 1-2 after each resample.

\noindent The procedure thus has 3 distinct components: 

i) a set of statistical tests comparing fixations to the target vs. competitor, 
ii) a criterion for deciding where the onset is, and 
iii) a way to generate a distribution of these onsets (resampling). 

The unique contribution of our procedure versus existing methods was iii): we estimate the sampling distribution of an onset in each condition, which we can then use to statistically compare onsets between conditions. 

The procedure yields two bootstrap distributions: one distribution each of onsets for the match and mismatch conditions. We take the mean and the 95th percentile confidence interval (CI) of the match/mismatch distributions as an estimate of the prediction onset for each condition and its temporal variability:




```{r, fig.width=7, fig.height=6, fig.align="center"}

# Plot Figure 5 of the manuscript
fig2ai <- ggplot(subset(df_l1l2, Condition == "match"), aes(onset)) + 
   geom_histogram(binwidth = 20, fill = "grey30", alpha = .3) +
   # create a panel for each language group
   facet_grid(~Condition, scales = "free", labeller = as_labeller(labels)) + 
   geom_point(data = filter(df_l1l2, Condition == "match"),
              aes(x = (mean(bootres_exp2$t[,2], na.rm = TRUE)-1)*20, y = 30), 
              size = 5) +
   geom_errorbarh(data = filter(df_l1l2, Condition == "match"),
                  aes(xmin = (boot::boot.ci(bootres_exp2, index = 2, 
                                            type = "perc")$percent[4]-1)*20,
                      xmax = (boot::boot.ci(bootres_exp2, index = 2, 
                                            type = "perc")$percent[5]-1)*20,
                      y = 30), size = 1, height = 90) +
   # aesthetic parameters
   labs(x = "Onset (ms)", y = "Frequency") +
   theme_light() +
   theme(strip.text = element_text(size = 16),
         text = element_text(size = 14, colour="gray28"),
         panel.spacing = unit(4, "lines"))


fig2aii <- ggplot(subset(df_l1l2, Condition == "mismatch"), aes(onset)) + 
   geom_histogram(binwidth = 20, fill = "grey30", alpha = .3) +
   # create a panel for each language group
   facet_grid(~Condition, scales = "free", labeller = as_labeller(labels)) + 
   geom_point(data = filter(df_l1l2, Condition == "mismatch"),
              aes(x = (mean(bootres_exp2$t[,3], na.rm = TRUE)-1)*20, y = 120), 
              size = 5) +
   geom_errorbarh(data = filter(df_l1l2, Condition == "mismatch"),
                  aes(xmin = (boot::boot.ci(bootres_exp2, index = 3, 
                                            type = "perc")$percent[4]-1)*20,
                      xmax = (boot::boot.ci(bootres_exp2, index = 3, 
                                            type = "perc")$percent[5]-1)*20,
                      y = 120), size = 1, height = 200) +
   # aesthetic parameters
   labs(x = "Onset (ms)", y = "Frequency") +
   xlim(c(680, 740)) +
   theme_light() +
   theme(strip.text = element_text(size = 16),
         text = element_text(size = 14, colour="gray28"),
         panel.spacing = unit(4, "lines"))


# create plotting data
plot_exp2 <- dat_exp2 %>% 
  filter(between(Time, 0, 1900) & Condition %in% c("match","mismatch")) %>%
  # downsample to every 100ms
  filter(Time %% 50 == 0) %>%
  # rename and reorder factor levels
  mutate(Region = fct_relevel(fct_recode(Region, target = "target", 
                                         competitor = "ccolour"), "target")) %>% 
  # create mean fixation proportions by participant
  group_by(Participant, Condition, Region, Time) %>%
  summarise(MeanFixation = mean(Value))

# general plot settings
col         <- c("#08519C","#08519C")
facet_names <- c(match = "Match", mismatch = "Mismatch")
onsets      <- c(800, 1800)
lty         <- c("solid", "dotdash")

# data frame for adding words to the plot
words <- data.frame(plot_exp2) %>%  
  select(c("Condition")) %>% 
  distinct(.keep_all=TRUE) 



# plot
fig2b <- ggplot(plot_exp2, aes(Time, MeanFixation)) +
  stat_summary(fun.data = mean_cl_boot, 
               aes(fill = Region), geom = "ribbon", alpha = .25) +
  stat_summary(fun = mean, geom = "path", 
               aes(group = Region, colour = Region, linetype = Region), size = 1) +
  facet_grid(. ~ Condition, labeller = as_labeller(facet_names)) +
  # add vertical lines for time windows
  geom_hline(yintercept = .5, linetype = "dotted") +
  geom_vline(xintercept = onsets, linetype = "dashed", colour = "grey50") +
  
  # add word stimuli
  geom_text(data = subset(words, Condition == "match"), label = "seinen", y = .15, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  geom_text(data = subset(words, Condition == "mismatch"), label = "ihren", y = .14, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "blauen", x = onsets[1]-60, y = .15, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "Knopf", x = onsets[2]-60, y = .13, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +

  # add bootstrapped onset and credible interval in the match condition
  geom_point(data = filter(plot_exp2, Condition == "match"), size = 4,
             aes(x = (mean(bootres_exp2$t[ ,2], na.rm = TRUE)-1)*20, y = .5)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "match"),size = 1, height = .075, 
                 aes(y    = .5,
                     xmin = (boot::boot.ci(bootres_exp2, index = 2, type = "perc")$percent[4]-1)*20,
                     xmax = (boot::boot.ci(bootres_exp2, index = 2, type = "perc")$percent[5]-1)*20)) +

  # add bootstrapped onset and credible interval in the mismatch condition
  geom_point(data = filter(plot_exp2, Condition == "mismatch"), size = 4,
             aes(x = (mean(bootres_exp2$t[ ,3], na.rm = TRUE)-1)*20, y = .5)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "mismatch"), size = 1, height = .075,
                 aes(y    = .5,
                     xmin = (boot::boot.ci(bootres_exp2, index = 3, type = "perc")$percent[4]-1)*20,
                     xmax = (boot::boot.ci(bootres_exp2, index = 3, type = "perc")$percent[5]-1)*20)) +
  
  # axes and legends
  labs(x = "Time from possessive onset (ms)", y = "Fixation proportions") +
  scale_x_continuous(breaks = seq(0, 2500, 500), labels = seq(0, 2500, 500)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_linetype_manual(values = lty, name = "Object") +
  scale_colour_manual(values = col, name = "Object") +
  scale_fill_manual(values = col, name = "Object") +
  
  # theme settings
  theme_light() +
  theme(strip.text = element_text(size = 16), text = element_text(size = 14), legend.position = "top")


# compile
(fig2 <- (fig2ai + fig2aii) / fig2b + plot_layout(heights = c(1, 2)) 
  # + plot_annotation(tag_levels = "A")
  )


# ggsave("C:/repos/stonekate.github.io/static/images/fig2.png", fig2, height = 10, width = 10, dpi = 300)

```

By subtracting the match from the mismatch distribution, we obtain a distribution of differences between conditions. We take the mean and the 95th percentile CI of this difference distribution as the estimated difference in prediction onset. We can decide whether the difference is different from zero by looking at whether the 95th percentile CI of the difference distribution contains zero. Since it does not, we can conclude that the difference between conditions is not zero. Moreover, since all values in the distribution are positive, we can conclude that predictions were slower in the mismatch condition:


```{r, fig.height = 3, fig.width = 4, fig.align="center"}


# Plot Figure 5 of the manuscript
(fig3 <- ggplot(subset(df_l1l2, Condition == "dp"), aes(onset)) + 
   geom_histogram(binwidth = 20, fill = "grey30", alpha = .3) +
   geom_vline(xintercept = 0, linetype = "dashed", colour = "grey30", width = 1) +
   facet_grid(~Condition, scales = "free", labeller = as_labeller(labels)) + 

   geom_point(data = filter(df_l1l2, Condition == "dp"),
              aes(x = mean(bootres_exp2$t[,1], na.rm = TRUE)*20, y = 30), 
              size = 4) +
   geom_errorbarh(data = filter(df_l1l2, Condition == "dp"),
                  aes(xmin = boot::boot.ci(bootres_exp2, index = 1, 
                                            type = "perc")$percent[4]*20,
                      xmax = boot::boot.ci(bootres_exp2, index = 1, 
                                            type = "perc")$percent[5]*20,
                      y = 30), size = 1, height = 70) +
   
   # aesthetic parameters
   labs(x = "Difference in onsets (ms)", y = "Frequency") +
   theme_light() +
   theme(text = element_text(size = 14, colour="gray28"),
         strip.text = element_text(size = 16),
         panel.spacing = unit(4, "lines")))

# ggsave("C:/repos/stonekate.github.io/static/images/fig3.png", fig3, height = 3, width = 4, dpi = 300)


```

***

#### Limitations of the bootstrap procedure


\noindent As mentioned earlier, the bootstrap makes some unlikely assumptions ([Bååth, 2018](http://www.sumsar.net/blog/2015/04/the-non-parametric-bootstrap-as-a-bayesian-model/)):

- Any values not seen in the observed data are impossible
- Each value in the observed data has an equal probability of occurring every time the experiment is run
- We have no prior knowledge about what datapoints might be observed

These assumptions limit our interpretation of the results. Another limitation of our procedure above is that while it allows us to conclude that there is a significant difference between match and mismatch prediction onsets, it does not allow us to quantify *how much* evidence we have for this conclusion. 

***

### Adding Bayesian principles 

```{r Prior}
# define a prior
prior_mean  <- 1000
prior_sd    <- 400
prior       <- data.frame(dens = dnorm(values, prior_mean, prior_sd))
```


```{r Likelihood}

# define a likelihood: we use a normal distribution

## match
likelihood_ma <- data.frame(dens=dnorm(values, mean(bootstrap_samples$match), 
                                        sd(bootstrap_samples$match)*(length(bootstrap_samples$match)-1)/length(bootstrap_samples$match)))

likelihood_mean_ma <- mean(bootstrap_samples$match, na.rm = TRUE)
likelihood_sd_ma   <- sd(bootstrap_samples$match, na.rm = TRUE)*(length(bootstrap_samples$match)-1)/length(bootstrap_samples$match)


## mismatch
likelihood_mi <- data.frame(dens=dnorm(values, mean(bootstrap_samples$mismatch), 
                                        sd(bootstrap_samples$mismatch)*(length(bootstrap_samples$mismatch)-1)/length(bootstrap_samples$mismatch)))

likelihood_mean_mi <- mean(bootstrap_samples$mismatch, na.rm = TRUE)
likelihood_sd_mi   <- sd(bootstrap_samples$mismatch, na.rm = TRUE)*(length(bootstrap_samples$mismatch)-1)/length(bootstrap_samples$mismatch)

```


```{r Posteriors}


# match
posterior_mean_ma  <- ((likelihood_mean_ma*prior_sd^2) + (prior_mean*likelihood_sd_ma^2)) /
                          (prior_sd^2 + likelihood_sd_ma^2)
posterior_sd_ma    <- sqrt( (likelihood_sd_ma^2 * prior_sd^2) / (likelihood_sd_ma^2 + prior_sd^2) )


# mismatch
posterior_mean_mi  <- ((likelihood_mean_mi*prior_sd^2) + (prior_mean*likelihood_sd_mi^2)) /
                          (prior_sd^2 + likelihood_sd_mi^2)
posterior_sd_mi    <- sqrt( (likelihood_sd_mi^2 * prior_sd^2) / (likelihood_sd_mi^2 + prior_sd^2) )




# the posterior of the difference between the match and mismatch conditions can 
# be computed as the difference between two normal distributions, see:
# https://mathworld.wolfram.com/NormalDifferenceDistribution.html
posterior_mean_exp2  <- posterior_mean_mi - posterior_mean_ma
posterior_sd_exp2    <- sqrt( posterior_sd_mi^2 + posterior_sd_ma^2 )
 

# difference posterior parameters
# round(posterior_mean_exp2) # mean
# round(qnorm(c(.025,.975), posterior_mean_exp2, posterior_sd_exp2)) # 95% CrI

# how much of posterior is above zero?
# 1-pnorm(0, posterior_mean_exp2, posterior_sd_exp2)
```


[Bayesian inference](https://en.wikipedia.org/wiki/Bayesian_inference) estimates our certainty about an event based on our prior knowledge about the probability of that event and new data. In our case, the event is prediction onsets. We can estimate our certainty about prediction onsets via Bayes' theorem, which estimates a [posterior probability distribution](https://en.wikipedia.org/wiki/Posterior_probability) using two components: priors to encode our expectations about when the onset could be, and data to inform posterior inference via a [likelihood function](https://en.wikipedia.org/wiki/Likelihood_function)^[Other possibilities for adding Bayesian principles to our procedure could have been to use the Bayesian Bootstrap ([Rubin, 1981](https://doi.org/10.1214/aos/1176345338)), implemented in R in `bayesboot` [(Bååth, 2018)](http://www.sumsar.net/blog/2016/02/bayesboot-an-r-package/). Unfortunately, `bayesboot` didn't suit our particular bootstrapping method, partly because it doesn't take a multi-step function like ours (see steps 1-3 above), but also because it doesn't take more informative priors---at least not currently. Alternatively, we could have fit e.g. GLMMs in `brms` [(Bürkner, 2018)](https://github.com/paul-buerkner/brms) to test between fixation proportions at each timepoint (step 1). But this would only apply Bayesian inference to estimating the *magnitude* of the difference in fixations between target and competitor at each timepoint, when what we really want is to apply it to finding the temporal variability of the onset.]. 

We start with the priors: we reasoned that predictiton onsets could only arise in the 1600 ms time window between the onset of the pronoun and the onset of the noun (adding 200 ms for saccade planning). We therefore specified a normal distribution centered in the middle of this critical window, with a 95% probability of the onset falling between 200 and 1800 ms: $N(1000,400)$. Our prior distributions for the match and mismatch conditions therefore looked like this:


```{r, fig.height=3, fig.width=8, fig.align="center"}

# par(las = 0, mfrow=c(1,2))


# match
# plot(density(na.omit(bootstrap_samples$match), bw = 10), xlim=xlims, col = "white", yaxt='n',
#      xlab = "Match onset (ms)", ylab = "Density",
#      main = "", frame.plot = FALSE)
# 
# # plot the prior
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# legend("topright", bty = "n", col = c("black"),
#        legend = c("prior"),
#        lty = c(1), lwd = c(2))

match_prior <- ggplot(data.frame(x = c(0, 1900), cond = "Match"), aes(x = x)) + 
  geom_density(data = bootstrap_samples, aes(match), colour = NA, fill = NA, bw=10) +
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd),
                aes(colour = "prior"), size = 1) + 
  scale_colour_manual("", breaks = c("prior"), values = c("black")) +
  labs(x = "Match onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 14),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))



# mismatch
# plot(density(na.omit(bootstrap_samples$mismatch), bw = 10), xlim=xlims, col = "white", yaxt='n',
#      xlab = "Mismatch onset (ms)", ylab = "",
#      main = "", frame.plot = FALSE)
# 
# # plot the prior
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# # legend("topright", bty = "n", col = c("grey50","black"),
# #        legend = c("prior"),
# #        lty = c(1), lwd = c(2))


# mismatch_prior <- ggplot(data.frame(x = c(0, 1900), cond = "Mismatch"), aes(x = x)) + 
#   geom_density(data = bootstrap_samples, aes(mismatch, colour = "data", linetype = "data", fill = "data"), bw=10) +
#   stat_function(geom = "area", fun = dnorm, n = 2000, 
#                 args = list(mean = prior_mean, sd = prior_sd),
#                 aes(colour = "prior", linetype = "prior", fill = "prior"), size = 1, alpha = .5) + 
#   scale_linetype_manual("", breaks = c("prior", "data"), values = c("solid", "solid")) +
#   scale_colour_manual("", breaks = c("prior", "data"), values = c("black", "white")) +
#   scale_fill_manual("", breaks = c("prior", "data"), values = c(NA, NA)) +
#   labs(x = "Mismatch onset (ms)", y = "Density") +
#   theme_light() +
#   theme(axis.text.y = element_blank(),
#         text = element_text(size = 14))

mismatch_prior <- match_prior +
  labs(x = "Mismatch onset (ms)", y = "Density")

match_prior + mismatch_prior + plot_layout(guides = "collect")


```

Next, we needed a likelihood function. This involved two steps: We used the bootstrap data to approximate a likelihood and a normal distribution to approximate a likelihood function (i.e. Laplace approximation). This was based on the assumption of the central limit theorem that the population distribution underlying the bootstrap data was approximately normal^[Using a normal distribution for the likelihood assumes that, with sufficient observations and bootstrap samples, the bootstrap distribution will approach a normal distribution in line with the central limit theorem. However, this is not always the case. An alternative way to define the likelihood would be to use a kernel density estimator instead: we present this approach in the appendices of [this paper](https://osf.io/3uz7x/).]. In other words, our likelihood function was a normal distribution with the mean and standard deviation of the bootstrap data: 


```{r, fig.height=3, fig.width=8, fig.align="center"}

# par(las = 0, mfrow=c(1,2))


# # add the likelihood to the plot
# plot(density(na.omit(bootstrap_samples$match), bw=10), xlim=xlims, col = "grey50", yaxt='n',
#      xlab = "Match onset (ms)", 
#      main = "", frame.plot = FALSE)
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_ma$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# legend("topright", bty = "n", col = c("grey50","black","black"), 
#        legend = c("bootstrap data","prior","likelihood"),
#        lty = c(1,1,2), lwd = c(2,2,2))



match_lik <- ggplot(data.frame(x = c(0, 1900), cond = "Match"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(match, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(match), bw=10, fill = "grey70", show.legend = FALSE) +  
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_ma, sd = likelihood_sd_ma),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood"), 
                      values = c("black", "grey70", "black"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood"),
                        values = c("solid", "solid", "dashed")) +
  labs(x = "Match onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))


# # add the likelihood to the plot
# plot(density(na.omit(bootstrap_samples$mismatch), bw=10), xlim=xlims, col = "grey50", yaxt='n',
#      xlab = "Mismatch onset (ms)", ylab = "",
#      main = "", frame.plot = FALSE)
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_mi$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# # legend("topleft", bty = "n", col = c("grey50","black","black"), 
# #        legend = c("bootstrap data","prior","likelihood"),
# #        lty = c(1,1,2), lwd = c(2,2,2))


mismatch_lik <- ggplot(data.frame(x = c(0, 1900), cond = "Mismatch"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(mismatch, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(mismatch), bw=10, fill = "grey70", show.legend = FALSE) +  
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_mi, sd = likelihood_sd_mi),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood"), 
                      values = c("black", "grey70", "black"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood"),
                        values = c("solid", "solid", "dashed")) +
  labs(x = "Mismatch onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))



match_lik + mismatch_lik + plot_layout(guides = "collect")
```

Finally, we could now derive the posterior distribution as the product of the prior and the likelihood. Because the prior and the likelihood are normal distributions, the posteriors for each condition can be derived analytically as the [product of two Gaussian probability density functions](https://ccrma.stanford.edu/~jos/sasp/Product_Two_Gaussian_PDFs.html), where

- $N(\mu_{prior},\sigma_{prior})$ is the prior,
- $N(\mu_{lik},\sigma_{lik})$ is the likelihood,
- $\mu_{posterior}$ is the mean of the posterior, and
- $\sigma_{posterior}$ is the standard deviation of $\mu_{posterior}$

The posterior distribution of the onset in the match condition is therefore:

$$ \begin{aligned}
\mu_{posterior} &= \frac{\mu_{prior} \sigma_{lik}^2 + \mu_{lik} \sigma_{prior}^2}{\sigma_{lik}^2 + \sigma_{prior}^2} \\
&= \frac{1000 \cdot 22^2 + 367 \cdot 400^2}{22^2 + 400^2} \\ &= 369 ms
\end{aligned}
$$

$$ \begin{aligned}
\sigma_{posterior} &= \sqrt\frac{\sigma_{prior}^2 \sigma_{lik}^2}{\sigma_{prior}^2 + \sigma_{lik}^2} \\ &= 
\sqrt\frac{400^2 \cdot 22^2}{400^2 + 22^2} \\ &= 22 ms 
\end{aligned}
$$

Via the same calculation, the posterior for the mismatch onset is 705 ms (SD = 9 ms). We can add these posteriors to our plots and see that they resemble the bootstrap data:

```{r, fig.height=3, fig.width=8, fig.align="center"}

# par(las = 0, mfrow=c(1,2))


# add the posterior to the plot
# plot(density(na.omit(bootstrap_samples$match), bw=10), xlim=xlims, col = "grey50", yaxt='n',
#      xlab = "Match onset (ms)", 
#      main = "", frame.plot = FALSE)
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_ma$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# lines(dnorm(0:1900, posterior_mean_ma, posterior_sd_ma), xlim=xlims, col = "red2", lwd = 2, lty=1)
# legend("topright", bty = "n", col = c("grey50","black","black","red2"), 
#        legend = c("bootstrap data","prior","likelihood","posterior"),
#        lty = c(1,1,2,1), lwd = c(2,2,2,2))


match_post <- ggplot(data.frame(x = c(0, 1900), cond = "Match"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(match, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(match), bw=10, fill = "grey70", show.legend = FALSE) +  
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_ma, sd = likelihood_sd_ma),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = posterior_mean_ma, sd = posterior_sd_ma),
                aes(colour = "posterior", linetype = "posterior")) +   
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"), 
                      values = c("black", "grey70", "black", "red2"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0,1)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"),
                        values = c("solid", "solid", "dashed", "solid")) +
  labs(x = "Match onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))


# add the posterior to the plot
# plot(density(na.omit(bootstrap_samples$mismatch), bw=10), xlim=xlims, col = "grey50", yaxt='n',
#      xlab = "Mismatch onset (ms)", ylab = "",
#      main = "", frame.plot = FALSE)
# lines(prior$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_mi$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# lines(dnorm(0:1900, posterior_mean_mi, posterior_sd_mi), xlim=xlims, col = "red2", lwd = 2, lty=1)
# # legend("topleft", bty = "n", col = c("grey50","black","black"), 
# #        legend = c("bootstrap data","prior","likelihood"),
# #        lty = c(1,1,2), lwd = c(2,2,2))


mismatch_post <- ggplot(data.frame(x = c(0, 1900), cond = "Mismatch"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(mismatch, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(mismatch), bw=10, fill = "grey70", show.legend = FALSE) +  
   stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_mi, sd = likelihood_sd_mi),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = posterior_mean_mi, sd = posterior_sd_mi),
                aes(colour = "posterior", linetype = "posterior")) +   
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"), 
                      values = c("black", "grey70", "black", "red2"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0,1)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"),
                        values = c("solid", "solid", "dashed", "solid")) +
  labs(x = "Mismatch onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))



match_post + mismatch_post + plot_layout(guides = "collect")
```


This is because our prior was relatively uninformative, and so the posteriors are informed more strongly by the bootstrap data than by the prior. If we had defined a strongly informative prior to say we were very certain that the prediction onsets would be 1000 ms, e.g. $N(1000, 10)$, then the posteriors would be pulled toward the prior (not completely, as they're still being informed by the data):

```{r, fig.height=3, fig.width=10, fig.align="center"}

# compute an analytical posterior
prior_mean      <- 1000
prior_sd_inf    <- 10
prior_inf       <- data.frame(dens = dnorm(values, prior_mean, prior_sd_inf))


# match
posterior_mean_ma_inf  <- ((likelihood_mean_ma*prior_sd_inf^2) + (prior_mean*likelihood_sd_ma^2)) /
                          (prior_sd_inf^2 + likelihood_sd_ma^2)
posterior_sd_ma_inf    <- sqrt( (likelihood_sd_ma^2 * prior_sd_inf^2) / (likelihood_sd_ma^2 + prior_sd_inf^2) )


# mismatch
posterior_mean_mi_inf  <- ((likelihood_mean_mi*prior_sd_inf^2) + (prior_mean*likelihood_sd_mi^2)) /
                          (prior_sd_inf^2 + likelihood_sd_mi^2)
posterior_sd_mi_inf    <- sqrt( (likelihood_sd_mi^2 * prior_sd_inf^2) / (likelihood_sd_mi^2 + prior_sd_inf^2) )


par(las = 0, mfrow=c(1,2))


# add the posterior to the plot
# plot(density(na.omit(bootstrap_samples$match), bw=10), xlim=xlims, 
#      ylim=c(0, max(prior_inf$dens)), col = "grey50", yaxt='n', cex = 2,
#      xlab = "Match onset (ms)", 
#      main = "", frame.plot = FALSE)
# lines(prior_inf$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_ma$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# lines(dnorm(0:1500, posterior_mean_ma_inf, posterior_sd_ma_inf), xlim=xlims, col = "red2", lwd = 2, lty=1)
# legend("topright", bty = "n", col = c("grey50","black","black","red2"),
#        legend = c("bootstrap data","prior","likelihood","posterior"),
#        lty = c(1,1,2,1), lwd = c(2,2,2,2))


match_prior_inf <- ggplot(data.frame(x = c(0, 1900), cond = "Match"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(match, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(match), bw=10, fill = "grey70", show.legend = FALSE) +  
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd_inf),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_ma, sd = likelihood_sd_ma),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = posterior_mean_ma_inf, sd = posterior_sd_ma_inf),
                aes(colour = "posterior", linetype = "posterior")) +   
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"), 
                      values = c("black", "grey70", "black", "red2"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0,1)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"),
                        values = c("solid", "solid", "dashed", "solid")) +
  labs(x = "Match onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))


# add the posterior to the plot
# plot(density(na.omit(bootstrap_samples$mismatch), bw=10), xlim=xlims, ylim=c(0, max(prior_inf$dens)), col = "grey50", yaxt='n',
#      xlab = "Mismatch onset (ms)", ylab = "",  cex = 2,
#      main = "", frame.plot = FALSE)
# lines(prior_inf$dens ~ values, xlim=xlims, lty = 1, lwd = 2)
# lines(likelihood_mi$dens ~ values, lty = 2, xlim=xlims, lwd = 2)
# lines(dnorm(0:1500, posterior_mean_mi_inf, posterior_sd_mi_inf), xlim=xlims, col = "red2", lwd = 2, lty=1)
# # legend("topleft", bty = "n", col = c("grey50","black","black","red2"), 
# #        legend = c("bootstrap data","prior","likelihood","posterior"),
# #        lty = c(1,1,2,1), lwd = c(2,2,2,2))


mismatch_prior_inf <- ggplot(data.frame(x = c(0, 1900), cond = "Mismatch"), aes(x = x)) + 
  stat_density(data = bootstrap_samples, geom = "line",
               aes(mismatch, colour = "bootstrap data", linetype = "bootstrap data"), 
               bw=10) +
  stat_density(data = bootstrap_samples, geom = "area",
               aes(mismatch), bw=10, fill = "grey70", show.legend = FALSE) +  
   stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean, sd = prior_sd_inf),
                aes(colour = "prior", linetype = "prior")) + 
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = likelihood_mean_mi, sd = likelihood_sd_mi),
                aes(colour = "likelihood", linetype = "likelihood")) +    
  stat_function(geom = "line", fun = dnorm, n = 2000, 
                args = list(mean = posterior_mean_mi_inf, sd = posterior_sd_mi_inf),
                aes(colour = "posterior", linetype = "posterior")) +   
  scale_colour_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"), 
                      values = c("black", "grey70", "black", "red2"),
                      guide = guide_legend(override.aes = list(lwd = c(1,1,0,1)))) +
  scale_linetype_manual("", breaks = c("prior", "bootstrap data", "likelihood", "posterior"),
                        values = c("solid", "solid", "dashed", "solid")) +
  labs(x = "Mismatch onset (ms)", y = "Density") +
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12),
        legend.key.width = unit(1,"cm")) +
  guides(colour = guide_legend(override.aes = list(size = 1)))



match_prior_inf + mismatch_prior_inf + plot_layout(guides = "collect")
```



How do the Bayesian onsets (red, uninformative priors) compare with the onsets from the original bootstrap procedure (black)? Quite well:

```{r, fig.height=3.5, fig.width=6, fig.align="center"}

# create plotting data
plot_exp2 <- dat_exp2 %>% 
  filter(between(Time, 0, 1900) & Condition %in% c("match","mismatch")) %>%
  # downsample to every 100ms
  filter(Time %% 50 == 0) %>%
  # rename and reorder factor levels
  mutate(Region = fct_relevel(fct_recode(Region, target = "target", 
                                         competitor = "ccolour"), "target")) %>% 
  # create mean fixation proportions by participant
  group_by(Participant, Condition, Region, Time) %>%
  summarise(MeanFixation = mean(Value))

# general plot settings
col         <- c("#08519C","#08519C")
facet_names <- c(match = "Match", mismatch = "Mismatch")
onsets      <- c(800, 1800)
lty         <- c("solid", "dotdash")

# data frame for adding words to the plot
words <- data.frame(plot_exp2) %>%  
  select(c("Condition")) %>% 
  distinct(.keep_all=TRUE) 

# plot
ggplot(plot_exp2, aes(Time, MeanFixation)) +
  stat_summary(fun.data = mean_cl_boot, 
               aes(fill = Region), geom = "ribbon", alpha = .25, show.legend = FALSE) +
  stat_summary(fun = mean, geom = "path", 
               aes(group = Region, colour = Region, linetype = Region), size = 1) +
  facet_grid(. ~ Condition, labeller = as_labeller(facet_names)) +
  
  # add vertical lines for time windows
  geom_hline(yintercept = .5, linetype = "dotted") +
  geom_vline(xintercept = onsets, linetype = "dashed", colour = "grey50") +
  
  # add word stimuli
  geom_text(data = subset(words, Condition == "match"), label = "seinen", y = .15, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  geom_text(data = subset(words, Condition == "mismatch"), label = "ihren", y = .14, 
            x = 0, angle = 90, fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "blauen", x = onsets[1]-60, y = .15, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +
  annotate(geom = "text", label = "Knopf", x = onsets[2]-60, y = .13, angle = 90,
           fontface = "italic", size = 4, colour = "grey50") +

  # add bootstrapped onset and credible interval in the match condition
  # original
  geom_point(data = filter(plot_exp2, Condition == "match"), size = 4,
             aes(x = mean(bootres_exp2$t[ ,2], na.rm = TRUE)*20, y = .5)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "match"),size = 1, height = .1, 
                 aes(y    = .5,
                     xmin = boot::boot.ci(bootres_exp2, index = 2, type = "perc")$percent[4]*20,
                     xmax = boot::boot.ci(bootres_exp2, index = 2, type = "perc")$percent[5]*20)) +
  # bayesian
  geom_point(data = filter(plot_exp2, Condition == "match"), size = 4, colour = "red2",
             aes(x = posterior_mean_ma, y = .6)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "match"),size = 1, height = .1, 
                 aes(y    = .6, 
                     xmin = round(qnorm(c(.025), posterior_mean_ma, posterior_sd_ma)),
                     xmax = round(qnorm(c(.975), posterior_mean_ma, posterior_sd_ma))), colour = "red2") +
  # add bootstrapped onset and credible interval in the mismatch condition
  # original
  geom_point(data = filter(plot_exp2, Condition == "mismatch"), size = 4,
             aes(x = mean(bootres_exp2$t[ ,3], na.rm = TRUE)*20, y = .5)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "mismatch"), size = 1, height = .1,
                 aes(y    = .5,
                     xmin = boot::boot.ci(bootres_exp2, index = 3, type = "perc")$percent[4]*20,
                     xmax = boot::boot.ci(bootres_exp2, index = 3, type = "perc")$percent[5]*20)) +
  # bayesian
  geom_point(data = filter(plot_exp2, Condition == "mismatch"), size = 4, colour = "red2",
             aes(x = posterior_mean_mi, y = .6)) +
  geom_errorbarh(data = filter(plot_exp2, Condition == "mismatch"),size = 1, height = .1, 
                 aes(y    = .6, 
                     xmin = round(qnorm(c(.025), posterior_mean_mi, posterior_sd_mi)),
                     xmax = round(qnorm(c(.975), posterior_mean_mi, posterior_sd_mi))), colour = "red2") +
  
  # axes and legends
  labs(x = "Time from possessive onset (ms)", y = "Fixation proportions") +
  scale_x_continuous(breaks = seq(0, 2500, 500), labels = seq(0, 2500, 500)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_linetype_manual(values = lty, name = "Object") +
  scale_colour_manual(values = col, name = "Object") +
  scale_fill_manual(values = col, name = "Object") +
  
  # theme settings
  theme_light() +
  theme(text = element_text(size = 14), legend.position = "top",
        strip.text = element_text(size = 16))

```



Now, how to decide whether the mismatch condition was slower? Because the match and mismatch posteriors are normal distributions, we can find the posterior of their difference as the [difference of two normal distributions](https://mathworld.wolfram.com/NormalDifferenceDistribution.html):

$$ \begin{aligned}
\mu_{posterior_{difference}} &= \mu_{posterior_{mismatch}} - \mu_{posterior_{match}} \\
 &= 705 - 369 \\
 &= 336 ms
\end{aligned}
$$

$$ \begin{aligned}
\sigma_{posterior_{difference}} &= \sqrt(\sigma^2_{posterior_{mismatch}} + \sigma^2_{posterior_{match}}) \\
 &= \sqrt(9^2 + 22^2) \\
 &= 24ms
\end{aligned}
$$

We now have a posterior estimate that predictions in the mismatch condition were 336 ms slower than in the match condition, with a 95\% credible interval of 288--384 ms. This posterior aligns quite well with the original bootstrap difference distribution, which estimated a difference of 338 ms with a 95th percentile interval of 300--380ms.



#### Quantifying evidence with a Bayes factor

\noindent How much has seeing the data changed our belief in the null hypothesis that the difference between match/mismatch conditions is zero? Since the likelihood is not normalised, we can use the Savage-Dickey method to compute a Bayes factor and quantify evidence against the null ([Dickey & Lientz, 1970](https://www.jstor.org/stable/2239734); [Wagenmakers et al., 2010](https://doi.org/10.1016/j.cogpsych.2009.12.001)). This method finds the ratio of prior to posterior density at some point value (e.g. zero): 


```{r, fig.height=3.5, fig.width=3.5, fig.align="center"}

values_diff <- seq(-1500, 1500, 1)

# define a prior for the difference by computing the difference distribution of 
# the individual match and mismatch priors:
prior_mean_diff   <- prior_mean - prior_mean
prior_sd_diff     <- sqrt(prior_sd^2 + prior_sd^2)
prior_diff        <- data.frame(dens = dnorm(values_diff, prior_mean_diff, prior_sd_diff))


# compute savage-dickey ratio
pointhyp <- 0

pointhyp.dens.prior     <- dnorm(pointhyp, prior_mean_diff, prior_sd_diff)
pointhyp.dens.posterior <- dnorm(pointhyp, posterior_mean_exp2, posterior_sd_exp2)

## tidy up these names for printing below
difference_prior_mean     <- prior_mean_diff
difference_prior_sd       <- prior_sd_diff
difference_posterior_mean <- posterior_mean_exp2
difference_posterior_sd   <- posterior_sd_exp2

# plot the ratio
# par(las = 0, mfrow=c(1,1))
# 
# plot(density(na.omit(bootstrap_samples$dp)), xlim=c(-1000, 1000), col = "white", yaxt='n',
#      xlab = "Match-mismatch onset difference (ms)", 
#      main = "", frame.plot = FALSE)
# # lines(c(0, 0), c(0, .008), lwd = 2, col = "grey")
# lines(dnorm(0:1500, posterior_mean_exp2, posterior_sd_exp2), xlim=c(-500, 1500), col = "red2", lwd = 2, lty=1)
# lines(prior_diff$dens ~ values_diff, xlim=c(-500, 1500), lty = 1, lwd = 2)
# points(0, pointhyp.dens.prior, cex = 2, pch = 21, bg = "grey")
# points(0, pointhyp.dens.posterior, cex = 2, pch = 21, bg = "pink", col = "red2")
# legend("topleft", bty = "n", 
#        legend = c("prior density\nat zero","\nposterior density\nat zero"),
#        pch = c(21,21), pt.bg = c("grey","pink"), pt.cex = c(2,2), col = c("black","red2"))


ggplot(data.frame(x = c(-750, 750), cond = "Difference"), aes(x = x)) + 
  stat_function(geom = "area", fun = dnorm, n = 2000, 
                args = list(mean = prior_mean_diff, sd = prior_sd_diff),
                colour = "black", fill = NA, alpha = .5) + 
  geom_point(aes(0, pointhyp.dens.prior), shape = 21, size = 5, colour = "black", fill = "grey", stroke = 1.5) +
  stat_function(geom = "area", fun = dnorm, n = 2000, 
                args = list(mean = difference_posterior_mean, sd = difference_posterior_sd),
                colour = "red2", fill = "red2", alpha = .3) +  
  geom_point(aes(0, pointhyp.dens.posterior), shape = 21, size = 5, colour = "red2", fill = "pink", stroke = 1.5) +
  geom_vline(xintercept = 0, linetype = "dashed", colour = "grey50") +
  geom_point(aes(-700, 0.0125), shape = 21, size = 4, colour = "black", fill = "grey", stroke = 1) +
  geom_text(aes(-330, 0.0126), label = "prior density at zero", size = 3) +
  geom_point(aes(-700, 0.0105), shape = 21, size = 4, colour = "red2", fill = "pink", stroke = 1) +
  geom_text(aes(-260, 0.0106), label = "posterior density at zero", size = 3) +
  labs(x = "Match-mismatch onset difference (ms)", y = "Density") + 
  theme_light() +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 12))

```


We compute the ratio via the equation below, where

- $\theta$ is the point at which we want to compare densities (e.g. zero), 
- $H_0$ is our prior distribution, 
- $H_1$ is our posterior distribution, and 
- $D$ is the data:

$$ BF_{01} = \frac{p(D|H_1)}{p(D|H_0)}= \frac{p(\theta = 0|H_1)}{p(\theta = 0|D,H_1)} $$

Or in R form:

```{r, echo=TRUE}
# define the null hypothesis
null_hypothesis <- 0

# find the density of the prior at the null hypothesis
density_prior_null     <- dnorm(null_hypothesis, 
                                difference_prior_mean, 
                                difference_prior_sd)

# find the density of the posterior at the null hypothesis
density_posterior_null <- dnorm(null_hypothesis, 
                                difference_posterior_mean, 
                                difference_posterior_sd)


# use Savage-Dickey equation to compute the Bayes factor
(BF01 <- density_posterior_null/density_prior_null)

```

The Bayes factor can be interpreted as a ratio of evidence for one hypothesis over the other. Because our posterior density at zero is less than the prior density (in fact, the posterior density at zero is almost zero), the Bayes factor is less than 1 and thus favours the alternative hypothesis that there is a match/mismatch difference. We can see more clearly how overwhelminlgy it favours the alternative hypothesis if we flip the ratio to test the alternative vs. null hypotheses (BF10) rather than the null vs. alternative (BF01):

```{r, echo=TRUE}

(BF10 <- 1/BF01)

```


### Conclusions

\noindent Using our Bayesian divergence point analysis, we find strong evidence that prediction onsets were slower when there were two conflicting gender cues. The posterior estimate of the "mismatch effect" size was 336 ms, with a 95\% credible interval of 288--384 ms. But our existing bootstrap procedure already led us to the same conclusion, so what was the advantage of adding Bayesian principles? 

The Bayesian approach has all the advantages that Bayesian inference has over frequentist null hypothesis significance testing. These include that the posterior is a continuous probability distribution that gives us information about the probability of non-observed values in the data. The 95\% credible interval can thus be interpreted as a range of possible between-condition differences in which the true size of the difference should lie with 95\% probability, given the data and the analysis. This interpretation is more intuitive than the percentile confidence interval from the existing bootstrap method, which just told us were 95\% of the resampled data lay. Moreover, we can now quantify evidence for our conclusions, and even for the null hypothesis. Finally, because the Bayesian method uses priors, we can use our posterior estimates as information about plausible effect sizes to inform the priors of future experiments.



<!-- ### Appendix 1 {-} -->

<!-- \noindent Above we mentioned that the distribution of our bootstrap data is not normal, and so using a normal distribution as a likelihood may not be appropriate. Instead, we can use a density function as our likelihood, although this means it is no longer possible to obtain the posterior as the product of two Gaussians. Also, our likelihood is still not normalised. To solve these issues, here we demonstrate how to use a density likelihood and obtain the posterior via sampling.  -->

<!-- First we define a likelihood for the match condition using a kernel density estimator of the original bootstrap data: -->

<!-- ```{r, echo=TRUE} -->
<!-- # define a range of onsets for which we would like to find onset probabilities, -->
<!-- # roughly corresponding to our window of interest: -->
<!-- values <- seq(0, 1900, 1) -->

<!-- # kernel density estimator: -->
<!-- density_likelihood_match  <- data.frame(dens = density(bootstrap_samples$match,  -->
<!--                                                     from = min(values), -->
<!--                                                     to = max(values), -->
<!--                                                     n = length(values))$y) -->

<!-- ``` -->

<!-- Then we need a density distribution for the prior using the prior mean and SD we used above: -->

<!-- ```{r, echo=TRUE} -->
<!-- density_prior_match <- data.frame(dens = dnorm(values,  -->
<!--                                                mean = prior_mean,  -->
<!--                                                sd = prior_sd)) -->

<!-- ``` -->


<!-- Then we multiply the likelihood and prior density distributions to get the posterior density distribution: -->

<!-- ```{r, echo=TRUE} -->
<!-- density_posterior_match <- data.frame(post = density_likelihood_match$dens *  -->
<!--                                         density_prior_match$dens) -->

<!-- ``` -->

<!-- And finally we sample from the posterior to obtain a *probability* distribution of onsets: -->

<!-- ```{r, echo=TRUE} -->
<!-- samples_posterior_match <- data.frame(post = sample(values, size=100000, -->
<!--                                     replace = TRUE, -->
<!--                                     prob = density_posterior_match$post)) -->
<!-- ``` -->


<!-- The parameters of our sampled posterior are: -->

<!-- ```{r, echo=TRUE} -->
<!-- # mean -->
<!-- round(mean(samples_posterior_match$post)) -->

<!-- # 95% CrI -->
<!-- quantile(samples_posterior_match$post, probs = c(.025, .975)) -->
<!-- ``` -->


<!-- We repeat for the  mismatch condition and get: -->

<!-- ```{r} -->
<!-- # define a likelihood using kernel density estimator -->
<!-- density_likelihood_mismatch   <- data.frame(dens = density(bootstrap_samples$mismatch,  -->
<!--                                                          from = min(values), -->
<!--                                                          to = max(values), -->
<!--                                                          n = length(values))$y) -->

<!-- # sample from the posterior using the density likelihood -->
<!-- ## create a density distribution of the prior -->
<!-- density_prior_mismatch        <- data.frame(dens = dnorm(values,  -->
<!--                                                          mean = prior_mean,  -->
<!--                                                          sd = prior_sd)) -->

<!-- ## then multiply the likelihood and prior PDFs -->
<!-- density_posterior_mismatch    <- data.frame(post = density_likelihood_mismatch$dens *  -->
<!--                                               density_prior_mismatch$dens) -->

<!-- ## then sample from the posterior -->
<!-- samples_posterior_mismatch    <- data.frame(post = sample(values, size = 100000, -->
<!--                                                     replace = TRUE, -->
<!--                                                     prob = density_posterior_mismatch$post)) -->

<!-- ``` -->

<!-- ```{r, echo=TRUE} -->
<!-- # mean -->
<!-- round(mean(samples_posterior_mismatch$post)) -->

<!-- # 95% CrI -->
<!-- quantile(samples_posterior_mismatch$post, probs = c(.025, 0.975)) -->

<!-- ``` -->


<!-- If we overlay these on our fixation curves, we can see that the sampling onset posteriors (purple) yield similar estimates to the normal distribution onset posteriors (red). This suggests that the normal distribution approach actually did a pretty good job approximating the posteriors, even though the bootstrap data didn't look very normal: -->


<!-- ```{r, fig.height=5, fig.width=10} -->
<!-- # match -->
<!-- posterior_mean_ma_norm <- mean(samples_posterior_match$post) -->
<!-- posterior_ci.lower_ma_norm <- quantile(samples_posterior_match$post, probs = c(.025))[[1]] -->
<!-- posterior_ci.upper_ma_norm <- quantile(samples_posterior_match$post, probs = c(.975))[[1]] -->

<!-- # mismatch -->
<!-- posterior_mean_mi_norm <- mean(samples_posterior_mismatch$post) -->
<!-- posterior_ci.lower_mi_norm <- quantile(samples_posterior_mismatch$post, probs = c(.025))[[1]] -->
<!-- posterior_ci.upper_mi_norm <- quantile(samples_posterior_mismatch$post, probs = c(.975))[[1]] -->

<!-- ### Plot -->

<!-- ggplot(plot_exp2, aes(Time, MeanFixation)) + -->
<!--   stat_summary(fun.data = mean_cl_boot,  -->
<!--                aes(fill = Region), geom = "ribbon", alpha = .25, show.legend = FALSE) + -->
<!--   stat_summary(fun = mean, geom = "path",  -->
<!--                aes(group = Region, colour = Region, linetype = Region), size = 1) + -->
<!--   facet_grid(.~ Condition, labeller = as_labeller(facet_names)) + -->

<!--   # add vertical lines for time windows -->
<!--   geom_hline(yintercept = .5, linetype = "dotted") + -->
<!--   geom_vline(xintercept = onsets, linetype = "dashed", colour = "grey50") + -->

<!--   # add word stimuli -->
<!--   geom_text(data = subset(words, Condition == "match"), label = "seinen", y = .13,  -->
<!--             x = 0, angle = 90, fontface = "italic", size = 5, colour = "grey50") + -->
<!--   geom_text(data = subset(words, Condition == "mismatch"), label = "ihren", y = .12,  -->
<!--             x = 0, angle = 90, fontface = "italic", size = 5, colour = "grey50") + -->
<!--   annotate(geom = "text", label = "blauen", x = onsets[1]-60, y = .13, angle = 90, -->
<!--            fontface = "italic", size = 5, colour = "grey50") + -->
<!--   annotate(geom = "text", label = "Knopf", x = onsets[2]-60, y = .11, angle = 90, -->
<!--            fontface = "italic", size = 5, colour = "grey50") + -->

<!--   # add bootstrapped onset and credible interval in the MATCH condition -->
<!--   ## normal likelihood method -->
<!--   geom_point(data = filter(plot_exp2, Condition == "match"),  -->
<!--              size = 4, colour = "red2", aes(x = posterior_mean_ma, y = .55)) + -->
<!--   geom_errorbarh(data = filter(plot_exp2, Condition == "match"), -->
<!--                  height = .07, colour = "red2", aes(y    = .55, -->
<!--                   xmin = qnorm(c(.025), posterior_mean_ma, posterior_sd_ma), -->
<!--                   xmax = qnorm(c(.975), posterior_mean_ma, posterior_sd_ma))) + -->

<!--   ## density likelihood method -->
<!--   geom_point(data = filter(plot_exp2, Condition == "match"), -->
<!--              size = 4, colour = "purple", aes(x = posterior_mean_ma_norm, y = .45)) + -->
<!--   geom_errorbarh(data = filter(plot_exp2, Condition == "match"), -->
<!--                  size = 1, height = .07, colour = "purple", -->
<!--                  aes(y    = .45, -->
<!--                      xmin = posterior_ci.lower_ma_norm, -->
<!--                      xmax = posterior_ci.upper_ma_norm)) + -->

<!--   # add bootstrapped onset and credible interval in the MISMATCH condition -->
<!--   ## normal likelihood method -->
<!--   geom_point(data = filter(plot_exp2, Condition == "mismatch"), -->
<!--              size = 4, colour = "red2", aes(x = posterior_mean_mi, y = .55)) + -->
<!--   geom_errorbarh(data = filter(plot_exp2, Condition == "mismatch"), -->
<!--                  size = 1, height = .07, colour = "red2", aes(y = .55, -->
<!--                     xmin = qnorm(c(.025), posterior_mean_mi, posterior_sd_mi), -->
<!--                     xmax = qnorm(c(.975), posterior_mean_mi, posterior_sd_mi))) + -->

<!--   ## density likelihood method -->
<!--   geom_point(data = filter(plot_exp2, Condition == "mismatch"), -->
<!--              size = 4, colour = "purple", aes(x = posterior_mean_mi_norm, y = .45)) + -->
<!--   geom_errorbarh(data = filter(plot_exp2, Condition == "mismatch"), -->
<!--                  height = .07, colour = "purple", -->
<!--                  aes(y    = .45, -->
<!--                      xmin = posterior_ci.lower_mi_norm, -->
<!--                      xmax = posterior_ci.upper_mi_norm)) + -->

<!--   # axes and legends -->
<!--   labs(x = "Time since possessive onset [ms]", y = "Fixations to objects") + -->
<!--   scale_x_continuous(breaks = seq(0, 2500, 500), labels = seq(0, 2500, 500)) + -->
<!--   scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + -->
<!--   scale_linetype_manual(values = lty, name = "Object:") + -->
<!--   scale_colour_manual(values = col, name = "Object:") + -->
<!--   scale_fill_manual(values = col, name = "Object:") + -->

<!--   # theme settings -->
<!--   theme_light() + -->
<!--   theme(text = element_text(size = 20),  -->
<!--         legend.position = "none", -->
<!--         strip.text = element_text(size = 20)) -->

<!-- ``` -->



<!-- ```{r, eval=FALSE, out.height="85%", out.width="75%", fig.align="center", fig.cap="\\label{fig:sampledlikelihood}Comparison of a posterior obtained as the product of two Gaussians (red) vs. via sampling (blue)."} -->

<!-- # posterior as multiplication of prior and likelihood pdfs, followed by sampling -->
<!-- plot(density(na.omit(bootstrap_samples$dp)), xlim=xlims, col = "grey50",  -->
<!--      xlab = "Match-mismatch onset difference (ms)",  -->
<!--      main = "Comparison of posterior methods", frame.plot = FALSE, yaxt = "n") -->
<!-- axis(side = 2, labels = FALSE) -->
<!-- lines(prior.df$dens ~ values, xlim=xlims, lty = 1, lwd = 2) -->
<!-- lines(likelihood.df$dens ~ values, lty = 2, xlim=xlims, lwd = 2) -->
<!-- abline(v=posterior.mean.sampled) -->
<!-- # lines(dnorm(0:600, posterior.mean.sampled, posterior.sd.sampled), xlim=xlims, col = "red2", lwd = 2, lty=1) -->
<!-- lines(likelihood$dens ~ values, lty = 2, xlim=xlims, lwd = 2, col="red2") -->
<!-- lines(density(posterior.samples$post), xlim=xlims, col = "blue4", lwd = 2, lty=1) -->
<!-- legend("topleft", bty = "n", col = c("grey50","black","black","red2","blue4"),  -->
<!--        legend = c("bootstrap data","prior","likelihood: density","likelihood: normal","posterior: sampled"), -->
<!--        lty = c(1,1,2,2,1), lwd = c(2,2,2,2,2)) -->


<!-- ``` -->
